/*
Вариант: 21
Процедура: Удаление всех повторов
Вид дерева: Дерево поиска 
Обход дерева: Обратный

В программе необходимо реализовать:
1. Структуру, необходимую для создания бинарного дерева.
2. Функцию, выполняющую процедуру, соответствующую заданию для
обработки построенного дерева.
3. Сохранение результатов выполнения процедуры в файл с учётом обхода,
соответствующего варианту

1. Числа в исходном файле записаны в одну строку, через одиночный пробел.
2. Результат работы программы записываются также в одну строку, через
одиночный пробел.
3. Дерево поиска и сбалансированное дерево — это разные деревья. Определение
сбалансированного дерева не содержит информации об упорядочивании
элементов на основе их значений. Дерево поиска ничего не говорит об особой
структуре дерева.
4. В любой непонятной ситуации ссылаться сначала «влево». Пример:
- для дерева поиска. В случае, если число больше корневого элемента –
«вправо», иначе (меньше или равно) – «влево»,
- для сбалансированного дерева – сначала добавлять элемент «влево».
*/

#include <iostream>
#include <fstream>

using namespace std;

struct node
{
	double value;
	node* left;
	node* right;
};

class Tree{
public:
	Tree(): val(0), left(), right(){}
	

	~Tree()
	{
	
	}
private:
	double val;
	node* left;
	node* right;
};


int main()
{



	return 0;
}